= Running Computations in Parallel

=== Basic parallel construct

=== Example: computing p-norm

* https://ko.wikipedia.org/wiki/%EB%85%B8%EB%A6%84[p-norm] is a generalization of the notion of length from geometry.


=== Main step: sum of powers of array segment

* First, solve sequentially the following sumSegment problem
** an integer array a, representing our vector
** a positive double floating point number p
** two valid indices s <= t into the array a

[source,scala]
----
def sumSegment(a: Array[Int], p: Double, s: Int, t: Int): Int = {
  var i = s; var sum: Int = 0
  while(i < t) {
    sum = sum + power(a(i), p)
    i = i + 1
  }
  sum
}

def power(x: Int, p: Double): Int = math.exp(p * math.log(abs(x))).toInt
----

=== Given sumSegment(a,p,s,t), how to compute p-norm?

[source,scala]
----
def pNorm(a: Array[Int], p: Double): Int =
  power(sumSegment(a, p, 0, a.length), 1/p)
----













=== Signature of parallel

[source,scala]
----
def parallel[A, B](taskA: => A, taskB => B): (A, B) = { ... }
----

* returns the same value as given
* benefit: parallel(a,b) can be faster than (a,b)
* it takes its arguments as by name, indicated with => A and => B


=== parallel is a control structure

[source,scala]
----
def parallel [A, B](taskA: => A, taskB => B): (A, B) = { ... }
def parallel1[A, B](taskA:    A, taskB    B): (A, B) = { ... }

val (va, vb) = parallel(a, b)
val (va, vb) = parallel1(a, b)
----

The second computation evaluates sequentially, as in val (va, vb) = (a, b)
For parallelism, need to pass unevaluated computations( call by name ).


=== What happens inside a system when we use parallel?

* Efficient parallelism requires support from
** language and libraries
** virtual machine
** operating system
** hardware
* One implementation of parallel uses Java Virtual Machine threads
** those typically map to operating system threads
** operating system can schedule different threads on multiple cores

**Give sufficient resources, a parallel program can run faster**

=== Underlying Hardware Architecture Affects Performance

[source,scala]
----
def sum1(a: Array[Int], p: Double, s: Int, t: Int): Int = {
    var i = s
    var sum: Int = 0
    while(i < t) {
      sum = sum + a(i) // no exponentiation!
      i = i + 1
    }
    sum
  }
}
val ((sum1,sum2),(sum3,sum4)) = parallel (
    parallel(sum(a, p, 0, m1), sum1(a, p, m1, m2)),
    parallel(sum(p, p, m2, m3), sum1(a, p, m3, a.length)0
  )
----

** Memory is a bottleneck! **


=== Combining computations of different length with parallel
